<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>演練組合配對產生器</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    input, textarea, label, select { margin: 5px; padding: 5px; }
    button { margin: 5px; padding: 6px 12px; cursor: pointer; }
    .pair { margin: 5px 0; }
    #history { width: 100%; height: 140px; }
    .muted { color: #666; font-size: 12px; }
    table { border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 5px 8px; text-align: center; min-width: 60px; }
    th { background: #f0f0f0; }
    .highlight { background: #c8f7c5; }
  </style>
</head>
<body>
  <h2>演練組合配對產生器</h2>

  <h3>人員名單</h3>
  <div id="peopleList"></div>
  <button onclick="addPerson()">➕ 新增人員</button>
  <button onclick="removePerson()">➖ 刪除人員</button>
  <div class="muted">小提醒：空白姓名不會被列入配對。</div>

  <h3>歷史配對紀錄 (請輸入過去組合，用逗號或換行分隔)</h3>
  <textarea id="history" placeholder="例：第1週 柳逸家-吳習賓, 張喬涵-郭瀞月"></textarea>

  <h3>設定</h3>
  <label>
    <input type="checkbox" id="allowRepeats"> 容許重複配對（若完全排除失敗，放寬條件並標記⚠️）
  </label>

  <br><br>
  <button onclick="generatePairs()">產生配對</button>

  <h3>配對結果：</h3>
  <div id="pairs"></div>

  <h3>配對關係矩陣表：</h3>
  <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
    <label>排序方式：</label>
    <select id="sortMode" onchange="onSortChange()">
      <option value="name_asc">依姓名排序（A→Z）</option>
      <option value="count_desc">依配對次數（高→低）</option>
      <option value="count_asc">依配對次數（低→高）</option>
    </select>
    <label>
      <input type="checkbox" id="filterNonZero" onchange="onSortChange()"> 只看大於 0 次
    </label>
    <label>
      <input type="checkbox" id="filterNewOnly" onchange="onSortChange()"> 只看當週新配對
    </label>
  </div>
  <div id="matrix"></div>
  <div style="margin-top:8px">
    <button onclick="downloadMatrixCSV()">⬇️ 下載矩陣 (CSV)</button>
    <button onclick="downloadMatrixXLSX()">⬇️ 下載矩陣 (Excel)</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script>
    const peopleListDiv = document.getElementById('peopleList');
    let people = ["柳逸家", "吳習賓", "張喬涵", "郭瀞月", "林苡姍", "鄔宜樺", "呂文勝", "許雅嵐", "蔡岢翰", "陳彥萍", "陳紫璇", "楊文益"];
    let latestNewPairs = [];

    function renderPeopleInputs() {
      peopleListDiv.innerHTML = '';
      people.forEach((name, index) => {
        const input = document.createElement('input');
        input.value = name;
        input.placeholder = '輸入姓名';
        input.oninput = () => people[index] = input.value;
        peopleListDiv.appendChild(input);
      });
    }

    function addPerson() {
      people.push('');
      renderPeopleInputs();
    }

    function removePerson() {
      if (people.length > 0) {
        people.pop();
        renderPeopleInputs();
      }
    }

    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    function parseHistoryCounts() {
      const text = document.getElementById('history').value;
      const tokens = text.split(/\n/).map(s => s.trim()).filter(Boolean);
      const counts = {}; // key -> count
      tokens.forEach(line => {
        const parts = line.replace(/^第\d+週\s*/, '').split(',');
        parts.forEach(p => {
          const [a, b] = p.split('-').map(s => (s || '').trim());
          if (a && b) {
            const key = [a, b].sort().join('-');
            counts[key] = (counts[key] || 0) + 1;
          }
        });
      });
      return counts;
    }

    function getNextWeekNumber() {
      const text = document.getElementById('history').value;
      const matches = text.match(/第(\d+)週/gi);
      if (!matches) return 1;
      const nums = matches.map(m => parseInt(m.replace(/第|週/g, '')));
      return Math.max(...nums) + 1;
    }

    function tryGeneratePairs(countsMap, allowRepeats, activePeople) {
      const shuffled = shuffle([...activePeople]);
      const pairs = [];
      for (let i = 0; i < shuffled.length; i += 2) {
        if (i + 1 < shuffled.length) {
          const pair = [shuffled[i], shuffled[i + 1]];
          const key = pair.slice().sort().join('-');
          if (!allowRepeats && (countsMap[key] || 0) > 0) {
            return null;
          }
          pairs.push(pair);
        } else {
          pairs.push([shuffled[i]]);
        }
      }
      return pairs;
    }

    function generatePairs() {
      const countsMap = parseHistoryCounts();
      const allowRepeats = document.getElementById('allowRepeats').checked;
      const activePeople = people.map(n => (n || '').trim()).filter(Boolean);

      const pairsDiv = document.getElementById('pairs');
      pairsDiv.innerHTML = '';

      if (activePeople.length === 0) {
        pairsDiv.style.color = 'red';
        pairsDiv.textContent = '請先輸入至少 1 位姓名。';
        return;
      }

      let pairs = null;
      let attempts = 0;
      const maxAttempts = 1000;

      while (!pairs && attempts < maxAttempts) {
        pairs = tryGeneratePairs(countsMap, false, activePeople);
        attempts++;
      }

      if (!pairs && allowRepeats) {
        pairs = tryGeneratePairs(countsMap, true, activePeople);
      }

      if (!pairs) {
        pairsDiv.style.color = 'red';
        pairsDiv.textContent = '⚠️ 無法在 ' + maxAttempts + ' 次嘗試內產生完全不重複的配對。可勾選「容許重複配對」。';
        return;
      }

      pairsDiv.style.color = 'black';
      const newHistoryEntries = [];
      const newPairKeys = [];

      pairs.forEach(pair => {
        const line = pair.join(' - ');
        const canonical = pair.slice().sort().join('-');
        const div = document.createElement('div');
        div.className = 'pair';
        if ((countsMap[canonical] || 0) > 0) {
          div.textContent = line + ' ⚠️ (重複)';
        } else {
          div.textContent = line;
        }
        pairsDiv.appendChild(div);
        if (pair.length === 2) {
          newHistoryEntries.push(line);
          newPairKeys.push(canonical);
        }
      });

      latestNewPairs = newPairKeys;

      const weekNum = getNextWeekNumber();
      const historyBox = document.getElementById('history');
      const currentText = historyBox.value.trim();
      const appended = `第${weekNum}週 ` + newHistoryEntries.join(', ');
      historyBox.value = currentText ? currentText + "\n" + appended : appended;

      const updatedCounts = parseHistoryCounts();
      renderMatrix(activePeople, updatedCounts, newPairKeys);
    }

    function renderMatrix(activePeople, countsMap, newPairKeys) {
      const sortMode = document.getElementById('sortMode').value;
      const filterNonZero = document.getElementById('filterNonZero').checked;
      const filterNewOnly = document.getElementById('filterNewOnly').checked;

      const personTotals = {};
      activePeople.forEach(p => personTotals[p] = 0);
      Object.keys(countsMap).forEach(k => {
        const [a, b] = k.split('-');
        if (personTotals[a] !== undefined) personTotals[a] += countsMap[k];
        if (personTotals[b] !== undefined) personTotals[b] += countsMap[k];
      });

      let ordered = [...activePeople];
      if (sortMode === 'count_desc') ordered.sort((x,y)=> (personTotals[y]||0) - (personTotals[x]||0) || x.localeCompare(y));
      else if (sortMode === 'count_asc') ordered.sort((x,y)=> (personTotals[x]||0) - (personTotals[y]||0) || x.localeCompare(y));
      else ordered.sort((x,y)=> x.localeCompare(y));

      if (filterNonZero) {
        ordered = ordered.filter(p => personTotals[p] > 0);
      }

      const matrixDiv = document.getElementById('matrix');
      let html = '<table><tr><th></th>';
      ordered.forEach(p => { html += `<th>${p}</th>`; });
      html += '<th>配對次數 (行)</th></tr>';

      ordered.forEach(row => {
        html += `<tr><th>${row}</th>`;
        ordered.forEach(col => {
          if (row === col) {
            html += '<td>-</td>';
          } else {
            const key = [row, col].sort().join('-');
            const count = countsMap[key] || 0;
            const isNew = latestNewPairs.includes(key);
            if (filterNewOnly) {
              html += isNew ? `<td class="highlight">${count}</td>` : '<td></td>';
            } else {
              if (isNew) html += `<td class="highlight">${count}</td>`;
              else html += `<td>${count > 0 ? count : ''}</td>`;
            }
          }
        });
        const rowTotal = ordered.reduce((acc,col)=> acc + (countsMap[[row,col].sort().join('-')]||0), 0);
        html += `<td>${rowTotal}</td></tr>`;
      });

      html += '<tr><th>配對次數 (列)</th>';
      ordered.forEach(col => {
        const colTotal = ordered.reduce((acc,row)=> acc + (countsMap[[row,col].sort().join('-')]||0), 0);
        html += `<td>${colTotal}</td>`;
      });
      const grandTotals = ordered.reduce((acc,row)=> acc + ordered.reduce((a,col)=> a + (countsMap[[row,col].sort().join('-')]||0), 0), 0);
      html += `<td>${grandTotals}</td></tr>`;

      html += '</table>';
      matrixDiv.innerHTML = html;
      matrixDiv.dataset.csv = JSON.stringify({ordered, countsMap});
    }

    function onSortChange() {
      const activePeople = people.map(n => (n || '').trim()).filter(Boolean);
      const countsMap = parseHistoryCounts();
      renderMatrix(activePeople, countsMap, []);
    }

    function downloadMatrixCSV() {
      const matrixDiv = document.getElementById('matrix');
      if (!matrixDiv.dataset.csv) return;
      const data = JSON.parse(matrixDiv.dataset.csv);
      const ordered = data.ordered;
      const pairs = data.countsMap;

      const header = ["", ...ordered, "配對次數 (行)"];
      const rows = [header];
      ordered.forEach(row => {
        const rowArr = [row];
        let rowTotal = 0;
        ordered.forEach(col => {
          if (row === col) rowArr.push('-');
          else {
            const key = [row,col].sort().join('-');
            const count = pairs[key] || 0;
            rowArr.push(count > 0 ? count : '');
            rowTotal += count;
          }
        });
        rowArr.push(rowTotal);
        rows.push(rowArr);
      });
      const footer = ["配對次數 (列)"];
      let grandTotal = 0;
      ordered.forEach(col => {
        const colTotal = ordered.reduce((acc,row)=> acc + (pairs[[row,col].sort().join('-')]||0), 0);
        footer.push(colTotal);
        grandTotal += colTotal;
      });
      footer.push(grandTotal);
      rows.push(footer);

      const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'pair_matrix.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadMatrixXLSX() {
      const matrixDiv = document.getElementById('matrix');
      if (!matrixDiv.dataset.csv) return;
      const data = JSON.parse(matrixDiv.dataset.csv);
      const ordered = data.ordered;
      const pairs = data.countsMap;

      const ws_data = [];
      ws_data.push(["", ...ordered, "配對次數 (行)"]);
      ordered.forEach(row => {
        const rowArr = [row];
        let rowTotal = 0;
        ordered.forEach(col => {
          if (row === col) rowArr.push('-');
          else {
            const key = [row,col].sort().join('-');
            const count = pairs[key] || 0;
            rowArr.push(count > 0 ? count : '');
            rowTotal += count;
          }
        });
        rowArr.push(rowTotal);
        ws_data.push(rowArr);
      });
      const footer = ["配對次數 (列)"];
      let grandTotal = 0;
      ordered.forEach(col => {
        const colTotal = ordered.reduce((acc,row)=> acc + (pairs[[row,col].sort().join('-')]||0), 0);
        footer.push(colTotal);
        grandTotal += colTotal;
      });
      footer.push(grandTotal);
      ws_data.push(footer);

      const ws = XLSX.utils.aoa_to_sheet(ws_data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "矩陣表");
      XLSX.writeFile(wb, "pair_matrix.xlsx");
    }

    renderPeopleInputs();
    renderMatrix(people.map(n => (n||'').trim()).filter(Boolean), parseHistoryCounts(), []);
  </script>
</body>
</html>
